import numpy as np

"""
* Transform an y in [0;1] generated by an uniform distribution to an x which follows the
* properties of a power law distribution.
* @param x0 - the lower bound for the numbers (corresponds to the minimal L_c)
* @param x1 - the upper bound (correspond to the maximum of L_c of the two satellites or infinite if
*              there is no upper bound)
 * @param n - the exponent from the power law distribution, more precisely the exponent of the
*              probability density function (pdf)
* @param y - the value from the uniform distribution to transform
 * @return the transformed x following the power law distribution
*/
"""
def power_law(x0, x1, n, y):
    step = pow(x1, n + 1) - pow(x0, n + 1) * y + pow(x0, n + 1)
    return pow(step, 1 / (n + 1))


def _kepler_equation(E, M, ecc):
    return E_to_M(E, ecc) - M


def _kepler_equation_prime(E, M, ecc):
    return 1 - ecc * np.cos(E)


def E_to_M(E, ecc):
    M = E - ecc * np.sin(E)
    return M


def _M_to_nu(M, ecc):
    E = M_to_E(M, ecc)
    nu = 2 * np.arctan(np.sqrt((1 + ecc) / (1 - ecc)) * np.tan(E / 2))
    return nu


def M_to_E(M, ecc):
    if -np.pi < M < 0 or np.pi < M:
        E0 = M - ecc
    else:
        E0 = M + ecc
    E = _newton_elliptic(E0, args=(M, ecc))
    return E


def newton_factory(func, fprime):

    def jit_newton_wrapper(x0, args=(), tol=1.48e-08, maxiter=50):
        p0 = float(x0)
        for _ in range(maxiter):
            fval = func(p0, *args)
            fder = fprime(p0, *args)
            newton_step = fval / fder
            p = p0 - newton_step
            if abs(p - p0) < tol:
                return p
            p0 = p

        return np.nan

    return jit_newton_wrapper


_newton_elliptic = newton_factory(_kepler_equation, _kepler_equation_prime)

def circle_area(characteristic_length):
    radius = characteristic_length / 2
    return np.pi * (radius**2)