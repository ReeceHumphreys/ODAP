import numpy as np

"""
* Transform an y in [0;1] generated by an uniform distribution to an x which follows the
* properties of a power law distribution.
* @param x0 - the lower bound for the numbers (corresponds to the minimal L_c)
* @param x1 - the upper bound (correspond to the maximum of L_c of the two satellites or infinite if
*              there is no upper bound)
 * @param n - the exponent from the power law distribution, more precisely the exponent of the
*              probability density function (pdf)
* @param y - the value from the uniform distribution to transform
 * @return the transformed x following the power law distribution
*/
"""

# TODO: Finish implementation of PowerLaw


def power_law(x0, x1, n, y):
    # step = x1**(n + 1) - x0**(n + 1) * y + x0**(n + 1)
    pass


def normalize_angle(angle):
    return (angle + 360) % 360


def normalize_radians(rad):
    return (rad + 2*np.pi) % 2*np.pi

def newton_raphson(E, M, ecc):
        accuracy = 1e-16
        max_loop = 100
        term = 0
        current_loop = 0
        while (abs(term / max(E, 1.0))
               ) > accuracy and (current_loop < max_loop):
            term = self.kep_E(E, M, ecc) / self.d_kep_E(E, ecc)
            E = E - term
            current_loop += 1
        return E

def kep_E(E, M, ecc):
    return (E - ecc * np.sin(E) - M)

def d_kep_E(E, ecc):
        return (1.0 - ecc * np.cos(E))
        
